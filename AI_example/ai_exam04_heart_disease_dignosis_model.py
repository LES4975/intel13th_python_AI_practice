# -*- coding: utf-8 -*-
"""AI_exam04_heart_disease_dignosis_model.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Y-tkUWke6XDKDNOWObgaaD4qZQR6-ENc

심장병 진단 데이터로 심장병 진단 모델 만들기!!!
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from keras.models import Sequential
from keras.layers import Dense, Dropout

column_names = ['age', 'sex', 'cp', 'treshbps', 'chol', 'fbs', 'restecg',
                'thalach', 'exang', 'oldpeak', 'slope', 'ca', 'thal', 'HeartDisease']
raw_data = pd.read_excel('../datasets/heart-disease.xlsx', names=column_names) # 파일을 읽어들여 데이터프레임 생성
print(raw_data.head())

raw_data.tail()

raw_data.info()

raw_data.describe()

"""데이터 전처리~"""

#결측치 처리하기
clean_data = raw_data.replace('?', np.nan) # '?'를 NaN으로 바꾸기
clean_data = clean_data.dropna() # NaN 값이 있는 데이터를 drop(제거)
print(clean_data.info())

#입력 데이터와 출력 데이터 분리
keep = column_names.pop() # 타겟으로 사용할 데이터 카테고리가 맨 뒤에 있으니까 그냥 pop()으로 뽑아냄
print(keep)
print(column_names)

training_data = clean_data[column_names] # 데이터프레임을 인덱싱
target = clean_data[[keep]]
print(training_data.head())
print(target.head())

print(target['HeartDisease'].sum()) # 합
print(target['HeartDisease'].mean()) # 평균 -> 심장병 진단율

#표준화
from sklearn.preprocessing import StandardScaler
scaler = StandardScaler()
scaled_data = scaler.fit_transform(training_data) # 평균을 0으로 조정해서 데이터를 변화
scaled_data = pd.DataFrame(scaled_data, columns=training_data.columns)
print(scaled_data.head())

print(scaled_data.describe().T)

boxplot = scaled_data.boxplot(column=column_names, showmeans=True)
plt.show()

"""데이터셋 분리~"""

from sklearn.model_selection import train_test_split
X_train, X_test, y_train, y_test = train_test_split(scaled_data, target, test_size=0.3)
print(X_train.shape)
print(X_test.shape)
print(y_train.shape)
print(y_test.shape)

"""모델 만들기~"""

model = Sequential()
model.add(Dense(512, input_dim=13, activation='relu')) # 입력 13개, 텐서 512개, ReLU 활성함수
model.add(Dense(256, activation='relu')) # (입력 512개) 텐서 256개, ReLU 활성함수
model.add(Dense(128, activation='relu')) # (입력 256개) 텐서 128개, ReLU 활성함수
model.add(Dense(1, activation='sigmoid')) # (입력 128개) 텐서 1개, Sigmoid 활성함수(마지막 결과는 0 아니면 1이 나와야 하기 때문에)
model.summary()

"""모델 학습시키기~"""

model.compile(loss='mse', optimizer='adam', metrics=['binary_accuracy'])
fit_hist = model.fit(X_train, y_train, epochs=50, batch_size=32, validation_split=0.2, verbose=1)

plt.plot(fit_hist.history['binary_accuracy'])
plt.plot(fit_hist.history['val_binary_accuracy'])
plt.title('Model Accuracy')
plt.xlabel('Accuracy')
plt.ylabel('Epoch')
plt.legend(['Train accuracy', 'Validation accuracy'], loc='lower right')
plt.show()

"""모델 검증하기~"""

score = model.evaluate(X_test, y_test, verbose=1)
print('loss', score[0])
print('accuracy', score[1])

"""정확도 높이기~"""

# 모델에 레이어 추가하기
model = Sequential()
model.add(Dense(512, input_dim=13, activation='relu'))
model.add(Dense(512, activation='relu'))
model.add(Dense(256, activation='relu'))
model.add(Dense(256, activation='relu'))
model.add(Dense(128, activation='relu'))
model.add(Dense(128, activation='relu'))
model.add(Dense(1, activation='sigmoid'))
model.summary()

model.compile(loss='mse', optimizer='adam', metrics=['binary_accuracy'])
fit_hist = model.fit(X_train, y_train, epochs=50, batch_size=32, validation_split=0.2, verbose=1)

plt.plot(fit_hist.history['binary_accuracy'])
plt.plot(fit_hist.history['val_binary_accuracy'])
plt.title('Model Accuracy')
plt.xlabel('Accuracy')
plt.ylabel('Epoch')
plt.legend(['Train accuracy', 'Validation accuracy'], loc='lower right')
plt.show()

score = model.evaluate(X_test, y_test, verbose=1)
print('loss', score[0])
print('accuracy', score[1])